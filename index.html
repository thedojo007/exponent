<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Walking Stick Figure Journal</title>
  <style>
    body {
      background: #181818;
      margin: 0;
      font-family: Arial, sans-serif;
      color: #ffe700;
      padding-top: 36px;
    }
    h1 {
      text-align: center;
      color: #ffe700;
      margin-bottom: 16px;
    }
    #prompt {
      text-align: center;
      font-size: 1.3em;
      margin-bottom: 12px;
    }
    #journalEntry {
      display: block;
      margin: 0 auto 30px auto;
      width: 340px;
      height: 1.7em;
      font-size: 1.1em;
      padding: 4px 10px;
      border: 2px solid #ffe700;
      border-radius: 6px;
      background: #252525;
      color: #ffe700;
      outline: none;
      transition: border 0.2s;
    }
    #journalEntry:focus {
      border: 2.5px solid #ffa733;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: #f5f2ea;
      box-shadow: 0 0 32px #181818;
    }
  </style>
</head>
<body>
  <h1>My Personal Journal</h1>
  <div id="prompt">What three things do you need to do today?</div>
  <input type="text" id="journalEntry" placeholder="Add your entry here..." />

  <canvas id="forestCanvas" width="400" height="600"></canvas>
  <script>
    // Canvas setup
    const canvas = document.getElementById("forestCanvas");
    const ctx = canvas.getContext("2d");

   function drawForestStatic(ctx) {
  const w = ctx.canvas.width;
  const h = ctx.canvas.height;

  // Soft grayscale background (mist)
  const bg = ctx.createLinearGradient(0, 0, 0, h);
  bg.addColorStop(0, '#f8f8f8');
  bg.addColorStop(0.55, '#f2f1ee');
  bg.addColorStop(1, '#eceae6');
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, w, h);

  // Very distant trees (lighter, thinner)
  const farXs = [25, 90, 155, 230, 300, 365];
  ctx.strokeStyle = '#d3d3d3';
  ctx.lineWidth = 3.5;
  farXs.forEach((x, i) => {
    const trunkHeight = 420 - i * 30;
    ctx.beginPath();
    ctx.moveTo(x, h);
    ctx.lineTo(x, h - trunkHeight);
    ctx.stroke();
    // sparse leaf clusters near top
    ctx.fillStyle = '#e3e3e3';
    for (let j = -1; j <= 1; j++) {
      ctx.beginPath();
      ctx.ellipse(x + j * 10, h - trunkHeight - 6, 10, 6, 0, 0, Math.PI * 2);
      ctx.fill();
    }
  });

  // Winding path (wide stroke to mimic filled path)
  ctx.save();
  ctx.lineCap = 'round';
  ctx.strokeStyle = '#d8d4cb';
  ctx.lineWidth = 36;
  ctx.beginPath();
  ctx.moveTo(80, h);
  ctx.bezierCurveTo(100, 400, 320, 400, 190, 0);
  ctx.stroke();

  // Subtle edge shading on the path
  ctx.strokeStyle = '#c9c3b9';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(80, h);
  ctx.bezierCurveTo(105, 405, 325, 395, 195, -5);
  ctx.stroke();
  ctx.restore();

  // Foreground trees (darker, thicker)
  const treeSpecs = [
    { x: 50,  h: 320 },
    { x: 95,  h: 270 },
    { x: 330, h: 340 },
    { x: 370, h: 280 },
    { x: 250, h: 220 },
    { x: 150, h: 320 }
  ];
  ctx.strokeStyle = '#242424';
  ctx.lineWidth = 7.5;
  treeSpecs.forEach(spec => {
    ctx.beginPath();
    ctx.moveTo(spec.x, h);
    ctx.lineTo(spec.x, h - spec.h);
    ctx.stroke();

    // simple canopy clusters
    ctx.fillStyle = '#d2d6d2';
    for (let j = -1; j <= 1; j++) {
      ctx.beginPath();
      ctx.ellipse(spec.x + j * 10, h - spec.h - 6, 11, 7, 0, 0, Math.PI * 2);
      ctx.fill();
    }
  });

  // Small rocks along the path
  const rocks = [
    { x: 88, y: h - 40, r: 4 },
    { x: 112, y: h - 90, r: 3 },
    { x: 270, y: 360, r: 4 },
    { x: 230, y: 300, r: 3 }
  ];
  ctx.fillStyle = '#bdb8ae';
  rocks.forEach(r => {
    ctx.beginPath();
    ctx.ellipse(r.x, r.y, r.r + 1, r.r, 0.2, 0, Math.PI * 2);
    ctx.fill();
  });

  // Caption on-canvas to match the reference
  ctx.fillStyle = 'rgba(0,0,0,0.8)';
  ctx.font = '22px Arial, sans-serif';
  ctx.fillText('what three things', 16, 22);
  ctx.fillText('do you need to do today?', 16, 48);
}

    // Stick figure animation variables
    let legPhase = 0;

    function drawStickFigure(x, y, phase) {
      ctx.save();
      ctx.lineWidth = 5;
      ctx.strokeStyle = "#181818";
      // Head
      ctx.beginPath();
      ctx.arc(x, y - 36, 12, 0, 2 * Math.PI);
      ctx.fillStyle = "#181818";
      ctx.fill();
      // Body
      ctx.beginPath();
      ctx.moveTo(x, y - 24);
      ctx.lineTo(x, y + 22);
      ctx.stroke();
      // Arms
      ctx.beginPath();
      ctx.moveTo(x - 22, y);
      ctx.lineTo(x + 22, y);
      ctx.stroke();
      // Legs (walking)
      const leg1x = x - 12 * Math.sin(phase), leg2x = x + 12 * Math.sin(phase);
      ctx.beginPath();
      ctx.moveTo(x, y + 22);
      ctx.lineTo(leg1x, y + 55);
      ctx.moveTo(x, y + 22);
      ctx.lineTo(leg2x, y + 55);
      ctx.stroke();
      ctx.restore();
    }

// Cache the static background
let bgCache = document.createElement('canvas');
bgCache.width = canvas.width;
bgCache.height = canvas.height;
let bgCtx = bgCache.getContext('2d');
// Draw the static scene into the cache (includes background fill)
drawForestStatic(bgCtx);

// Draw the cached background to the visible canvas immediately
ctx.drawImage(bgCache, 0, 0);

// Persist journal input and overlay it on the canvas
const entryEl = document.getElementById("journalEntry");
let entryText = localStorage.getItem("journalEntry") || "";
if (entryEl) {
  entryEl.value = entryText;
  entryEl.addEventListener("input", () => {
    entryText = entryEl.value;
    try {
      localStorage.setItem("journalEntry", entryText);
    } catch (_) {
      // Ignore storage errors (e.g., privacy mode)
    }
  });
}

function getTasks() {
  return entryText
    .split(",")
    .map(s => s.trim())
    .filter(Boolean)
    .slice(0, 3);
}

function drawOverlay() {
  const padding = 14;
  const boxWidth = canvas.width - padding * 2;
  const tasks = getTasks();
  const boxHeight = tasks.length ? 24 + tasks.length * 22 : 40;

  ctx.save();
  ctx.fillStyle = 'rgba(24,24,24,0.6)';
  ctx.fillRect(padding, padding, boxWidth, boxHeight);
  ctx.font = '16px Arial, sans-serif';
  ctx.textBaseline = 'top';
  ctx.fillStyle = '#ffe700';

  if (tasks.length) {
    for (let i = 0; i < tasks.length; i++) {
      ctx.fillText(`${i + 1}. ${tasks[i]}`, padding + 10, padding + 8 + i * 22);
    }
  } else {
    ctx.fillStyle = '#d2c200';
    ctx.fillText('Type your top 3 tasks...', padding + 10, padding + 10);
  }
  ctx.restore();
}

// Path definition used for walking animation (matches the drawn path)
const P0 = { x: 80, y: 600 };
const P1 = { x: 100, y: 400 };
const P2 = { x: 320, y: 400 };
const P3 = { x: 190, y: 0 };

function cubic(p0, p1, p2, p3, t) {
  const u = 1 - t;
  return u * u * u * p0 + 3 * u * u * t * p1 + 3 * u * t * t * p2 + t * t * t * p3;
}

function pointOnPath(t) {
  return {
    x: cubic(P0.x, P1.x, P2.x, P3.x, t),
    y: cubic(P0.y, P1.y, P2.y, P3.y, t)
  };
}

// Animation loop
let lastTs = 0;
let walkerT = 0;
const walkerSpeedPerMs = 0.00012; // fraction of the path per millisecond

function render(ts) {
  if (!lastTs) lastTs = ts;
  const delta = ts - lastTs;
  lastTs = ts;

  // Advance animation state
  legPhase += delta * 0.008;
  walkerT += delta * walkerSpeedPerMs;
  if (walkerT > 1) walkerT = 0;

  // Draw frame
  ctx.drawImage(bgCache, 0, 0);
  const pos = pointOnPath(walkerT);
  // Raise the figure slightly so feet sit closer to the path
  drawStickFigure(pos.x, pos.y - 10, legPhase);
  drawOverlay();

  requestAnimationFrame(render);
}

requestAnimationFrame(render);

  </script>
</body>
</html>
